diff --git a/backend/server.py b/backend/server.py
index 9e779f9..ddf1104 100644
--- a/backend/server.py
+++ b/backend/server.py
@@ -8,6 +8,7 @@ import logging
 import asyncio
 import hashlib
 import secrets
+import re
 from pathlib import Path
 from pydantic import BaseModel, Field, ConfigDict, EmailStr
 from typing import List, Optional, Dict, Any
@@ -307,7 +308,13 @@ class PriceListCreate(BaseModel):
     active: bool = True
 
 class PriceListUpdate(BaseModel):
-    price: Optional[float] = None
+    article: Optional[str] = None
+    name: Optional[str] = None
+    unit: Optional[str] = None
+    pack_quantity: Optional[int] = None
+    min_order: Optional[int] = None
+    unit_price: Optional[float] = None
+    price: Optional[float] = None  # legacy, maps to unit_price
     availability: Optional[bool] = None
     active: Optional[bool] = None
 
@@ -590,6 +597,75 @@ async def register_customer(data: CustomerRegistration):
         }
     )
 
+# ==================== DEV AUTH BYPASS ====================
+DEV_AUTH_BYPASS = os.environ.get("DEV_AUTH_BYPASS", "").strip() == "1"
+
+class DevLoginRequest(BaseModel):
+    role: str  # "supplier" | "customer"
+    email: Optional[str] = None
+    phone: Optional[str] = None
+
+@api_router.post("/dev/login", response_model=TokenResponse)
+async def dev_login(data: DevLoginRequest):
+    """DEV-only: login without password. Returns 404 when DEV_AUTH_BYPASS != 1."""
+    if not DEV_AUTH_BYPASS:
+        raise HTTPException(status_code=404, detail="Not Found")
+    role = (data.role or "supplier").strip().lower()
+    if role not in ("supplier", "customer"):
+        raise HTTPException(status_code=400, detail="role must be supplier or customer")
+    user = None
+    company_id = None
+    if data.email:
+        user = await db.users.find_one({"email": data.email.strip(), "role": role}, {"_id": 0})
+    if not user and data.phone:
+        phone_norm = "".join(c for c in str(data.phone) if c.isdigit())[-10:]
+        async for c in db.companies.find({"type": role}, {"_id": 0, "id": 1, "userId": 1, "phone": 1, "contactPersonPhone": 1}):
+            cp = (c.get("phone") or c.get("contactPersonPhone") or "")
+            if phone_norm in "".join(x for x in cp if x.isdigit()):
+                user = await db.users.find_one({"id": c["userId"]}, {"_id": 0})
+                company_id = c["id"]
+                break
+    if not user:
+        user = await db.users.find_one({"role": role}, {"_id": 0})
+    if user:
+        if not company_id and user.get("role") != "responsible":
+            company = await db.companies.find_one({"userId": user["id"]}, {"_id": 0, "id": 1})
+            company_id = company["id"] if company else None
+        token = create_access_token({"sub": user["id"], "role": user["role"]})
+        return TokenResponse(
+            access_token=token,
+            user={"id": user["id"], "email": user.get("email", ""), "role": user["role"], "companyId": company_id}
+        )
+    user_id = str(uuid.uuid4())
+    company_id = str(uuid.uuid4())
+    email = data.email or f"dev-{role}@local.dev"
+    now = datetime.now(timezone.utc).isoformat()
+    user_doc = {
+        "id": user_id, "email": email, "passwordHash": hash_password("dev-no-password"),
+        "role": role, "createdAt": now, "updatedAt": now
+    }
+    company_doc = {
+        "id": company_id, "type": role, "userId": user_id,
+        "inn": "0000000000", "ogrn": "0000000000000",
+        "companyName": f"DEV {role.title()}",
+        "legalAddress": "DEV", "actualAddress": "DEV", "phone": "+70000000000",
+        "email": email, "contractAccepted": True, "createdAt": now, "updatedAt": now
+    }
+    await db.users.insert_one(user_doc)
+    await db.companies.insert_one(company_doc)
+    if role == "supplier":
+        await db.supplier_settings.insert_one({
+            "id": str(uuid.uuid4()), "supplierCompanyId": company_id,
+            "minOrderAmount": 0, "deliveryDays": [], "deliveryTime": "", "orderReceiveDeadline": "",
+            "logisticsType": "own", "updatedAt": now
+        })
+    token = create_access_token({"sub": user_id, "role": role})
+    return TokenResponse(
+        access_token=token,
+        user={"id": user_id, "email": email, "role": role, "companyId": company_id}
+    )
+
+
 @api_router.post("/auth/login", response_model=TokenResponse)
 async def login(data: UserLogin):
     user = await db.users.find_one({"email": data.email}, {"_id": 0})
@@ -630,7 +706,7 @@ async def lookup_inn(inn: str):
     }
 
 
-# ==================== FORGOT / RESET PASSWORD ====================
+# ==================== PASSWORD RECOVERY ====================
 
 class ForgotPasswordRequest(BaseModel):
     email: EmailStr
@@ -650,7 +726,6 @@ def _send_reset_email(to_email: str, reset_link: str) -> bool:
     smtp_port = int(os.environ.get('SMTP_PORT', '587'))
     from_email = os.environ.get('SMTP_FROM', smtp_user or 'noreply@bestprice.local')
     if not smtp_host or not smtp_user or not smtp_pass:
-        logger.info(f"RESET LINK (dev mode, SMTP not configured): {reset_link}")
         return False
     try:
         import smtplib
@@ -694,7 +769,7 @@ async def forgot_password(data: ForgotPasswordRequest):
             "created_at": datetime.utcnow(),
         })
         reset_link = f"{frontend_url}/supplier/reset-password?token={raw_token}"
-        print("RESET LINK:", reset_link)
+        print(f"RESET LINK: {reset_link}")
         _send_reset_email(data.email, reset_link)
     return {"message": "If email exists, we sent a reset link."}
 
@@ -713,9 +788,9 @@ async def reset_password(data: ResetPasswordRequest):
 
     now = datetime.utcnow()
     expires = rec["expires_at"]
-    if expires.tzinfo is not None:
+    if expires is not None and hasattr(expires, 'tzinfo') and expires.tzinfo is not None:
         expires = expires.replace(tzinfo=None)
-    if now > expires:
+    if expires is not None and now > expires:
         raise HTTPException(status_code=400, detail="Token expired")
 
     new_hash = hash_password(data.newPassword)
@@ -730,6 +805,166 @@ async def reset_password(data: ResetPasswordRequest):
     return {"message": "Password updated."}
 
 
+# ==================== PHONE OTP ====================
+
+def _normalize_phone(phone: str) -> str:
+    s = re.sub(r'\D', '', str(phone).strip())
+    if not s:
+        return ""
+    if s.startswith('8') and len(s) == 11:
+        s = '7' + s[1:]
+    elif len(s) == 10:
+        s = '7' + s
+    elif s.startswith('7') and len(s) != 11:
+        pass
+    return '+' + s
+
+def _phone_matches(company_phone: str, normalized: str) -> bool:
+    n2 = _normalize_phone(company_phone or '')
+    return n2 == normalized and bool(normalized)
+
+PHONE_OTP_COLLECTION = "phone_otp"
+PHONE_OTP_EXPIRE_MINUTES = 5
+PHONE_OTP_MAX_ATTEMPTS = 5
+PHONE_REQUEST_COOLDOWN_SEC = 60
+
+def _hash_otp(otp: str) -> str:
+    return hashlib.sha256(otp.encode('utf-8')).hexdigest()
+
+def _send_sms(phone: str, text: str, otp: str = "") -> bool:
+    """
+    Dev fallback: если SMS не настроен — печатает OTP в лог и возвращает True.
+    Никаких return False в dev-сценариях.
+    """
+    def _dev_fallback(reason: str = ""):
+        code = otp or text
+        print(f"OTP CODE: {code} (to {phone}) {reason}".strip())
+        return True
+
+    provider = os.environ.get("SMS_PROVIDER", "").strip().lower()
+    if provider != "twilio":
+        return _dev_fallback("[dev: SMS_PROVIDER!=twilio]")
+
+    sid = os.environ.get("TWILIO_ACCOUNT_SID", "").strip()
+    token_env = os.environ.get("TWILIO_AUTH_TOKEN", "").strip()
+    from_num = os.environ.get("TWILIO_PHONE_FROM", "").strip()
+
+    if not (sid and token_env and from_num):
+        return _dev_fallback("[dev: missing TWILIO* env]")
+
+    try:
+        from twilio.rest import Client
+        client = Client(sid, token_env)
+        client.messages.create(body=text, from_=from_num, to=phone)
+        return True
+    except Exception as e:
+        return _dev_fallback(f"[dev: twilio error: {e}]")
+
+class PhoneRequestOtpRequest(BaseModel):
+    phone: str
+    role: Optional[str] = "supplier"
+
+class PhoneResetPasswordRequest(BaseModel):
+    phone: str
+    otp: str
+    new_password: str
+    role: Optional[str] = "supplier"
+
+@api_router.post("/auth/phone/request-otp")
+async def phone_request_otp(data: PhoneRequestOtpRequest):
+    print("PHONE OTP: request-otp HIT")
+    role = (data.role or "supplier").strip().lower()
+    if role != "supplier":
+        print(f"PHONE OTP: role not supplier -> {role}")
+        return {"message": "If phone exists, code sent."}
+    phone_norm = _normalize_phone(data.phone)
+    print(f"PHONE OTP: normalized={phone_norm} raw={data.phone}")
+    if not phone_norm or len(phone_norm) < 11:
+        print("PHONE OTP: invalid normalized phone -> early return")
+        return {"message": "If phone exists, code sent."}
+
+    coll = db[PHONE_OTP_COLLECTION]
+    existing = await coll.find_one({"phone": phone_norm, "role": "supplier"})
+    if existing and existing.get("created_at"):
+        created = existing["created_at"]
+        if hasattr(created, "tzinfo") and created.tzinfo:
+            created = created.replace(tzinfo=None)
+
+        diff = (datetime.utcnow() - created).total_seconds()
+        print(f"PHONE OTP: cooldown check diff={diff} sec")
+
+        if diff < PHONE_REQUEST_COOLDOWN_SEC:
+            print("PHONE OTP: cooldown triggered -> early return")
+            return {"message": "If phone exists, code sent."}
+
+    # проверяем что телефон реально есть среди supplier компаний
+    found = False
+    async for c in db.companies.find({"type": "supplier"}):
+        if _phone_matches(c.get("phone") or c.get("contactPersonPhone") or "", phone_norm):
+            found = True
+            break
+    if not found:
+        print("PHONE OTP: supplier with this phone NOT FOUND -> early return")
+        return {"message": "If phone exists, code sent."}
+
+    otp = f"{secrets.randbelow(900000) + 100000}"
+    print(f"DEBUG OTP GENERATED: {otp}")
+    otp_hash = _hash_otp(otp)
+    expires_at = datetime.utcnow() + timedelta(minutes=PHONE_OTP_EXPIRE_MINUTES)
+    await coll.delete_many({"phone": phone_norm, "role": "supplier"})
+    await coll.insert_one({
+        "phone": phone_norm,
+        "role": "supplier",
+        "otp_hash": otp_hash,
+        "expires_at": expires_at,
+        "attempts": 0,
+        "created_at": datetime.utcnow(),
+    })
+    print("AFTER INSERT - CALLING SEND_SMS")
+    _send_sms(phone_norm, f"Your OTP is {otp}", otp=otp)
+    return {"message": "If phone exists, code sent."}
+
+@api_router.post("/auth/phone/reset-password")
+async def phone_reset_password(data: PhoneResetPasswordRequest):
+    role = (data.role or "supplier").strip().lower()
+    if role != "supplier":
+        raise HTTPException(status_code=400, detail="Invalid request")
+    phone_norm = _normalize_phone(data.phone)
+    coll = db[PHONE_OTP_COLLECTION]
+    rec = await coll.find_one({"phone": phone_norm, "role": "supplier"}, {"_id": 0, "otp_hash": 1, "expires_at": 1, "attempts": 1})
+    if not rec:
+        raise HTTPException(status_code=400, detail="Invalid or expired code")
+    if rec.get("attempts", 0) >= PHONE_OTP_MAX_ATTEMPTS:
+        await coll.delete_one({"phone": phone_norm, "role": "supplier"})
+        raise HTTPException(status_code=400, detail="Too many attempts")
+    now = datetime.utcnow()
+    expires = rec.get("expires_at")
+    if expires:
+        if hasattr(expires, 'tzinfo') and expires.tzinfo:
+            expires = expires.replace(tzinfo=None)
+        if now > expires:
+            await coll.delete_one({"phone": phone_norm, "role": "supplier"})
+            raise HTTPException(status_code=400, detail="Code expired")
+    if _hash_otp(data.otp) != rec.get("otp_hash"):
+        await coll.update_one({"phone": phone_norm, "role": "supplier"}, {"$inc": {"attempts": 1}})
+        raise HTTPException(status_code=400, detail="Invalid code")
+    user_id = None
+    async for c in db.companies.find({"type": "supplier"}, {"_id": 0, "userId": 1, "phone": 1, "contactPersonPhone": 1}):
+        if _phone_matches(c.get("phone") or c.get("contactPersonPhone") or "", phone_norm):
+            user_id = c.get("userId")
+            break
+    if not user_id:
+        await coll.delete_one({"phone": phone_norm, "role": "supplier"})
+        raise HTTPException(status_code=400, detail="Invalid or expired code")
+    new_hash = hash_password(data.new_password)
+    await db.users.update_one(
+        {"id": user_id},
+        {"$set": {"passwordHash": new_hash, "updatedAt": datetime.utcnow().isoformat()}}
+    )
+    await coll.delete_one({"phone": phone_norm, "role": "supplier"})
+    return {"message": "Password updated."}
+
+
 @api_router.get("/auth/me")
 async def get_me(current_user: dict = Depends(get_current_user)):
     company_id = current_user.get("companyId")
@@ -826,6 +1061,7 @@ async def update_my_supplier_settings(data: SupplierSettingsUpdate, current_user
 
 # ==================== PRICE LIST ROUTES ====================
 
+@api_router.get("/supplier/price-list")
 @api_router.get("/price-lists/my")
 async def get_my_price_lists(current_user: dict = Depends(get_current_user)):
     """Return supplier's price list items from supplier_items (single source of truth)."""
@@ -846,13 +1082,17 @@ async def get_my_price_lists(current_user: dict = Depends(get_current_user)):
         updated = si.get("updated_at") or si.get("created_at")
         result.append({
             "id": si.get("id", si.get("unique_key", "")),
-            "supplierCompanyId": si.get("supplier_company_id", company_id),
-            "productName": si.get("name_raw", ""),
             "article": si.get("supplier_item_code", ""),
-            "price": float(si.get("price", 0)),
+            "name": si.get("name_raw", ""),
             "unit": si.get("unit_supplier", si.get("unit_norm", "шт")),
+            "pack_quantity": int(si.get("pack_qty", 1)),
+            "min_order": int(si.get("min_order_qty", 1)),
+            "unit_price": float(si.get("price", 0)),
+            "availability": bool(si.get("active", True)),
+            "price": float(si.get("price", 0)),  # legacy
+            "productName": si.get("name_raw", ""),
+            "supplierCompanyId": si.get("supplier_company_id", company_id),
             "minQuantity": int(si.get("min_order_qty", 1)),
-            "availability": True,
             "active": si.get("active", True),
             "createdAt": created.isoformat() if hasattr(created, "isoformat") else str(created),
             "updatedAt": updated.isoformat() if hasattr(updated, "isoformat") else str(updated),
@@ -923,7 +1163,7 @@ async def create_price_list(data: PriceListCreate, current_user: dict = Depends(
 
 @api_router.put("/price-lists/{price_id}")
 async def update_price_list(price_id: str, data: PriceListUpdate, current_user: dict = Depends(get_current_user)):
-    """Update one price list item in supplier_items."""
+    """Update one price list item in supplier_items. Accepts article, name, unit, pack_quantity, min_order, unit_price, availability."""
     if current_user['role'] != UserRole.supplier:
         raise HTTPException(status_code=403, detail="Not authorized")
     company_id = current_user.get('companyId')
@@ -932,16 +1172,26 @@ async def update_price_list(price_id: str, data: PriceListUpdate, current_user:
         company_id = company['id'] if company else None
     if not company_id:
         raise HTTPException(status_code=404, detail="Company not found")
-    set_fields = {}
-    if data.price is not None:
-        set_fields["price"] = float(data.price)
+    set_fields = {"updated_at": datetime.now(timezone.utc)}
+    price_val = data.unit_price if data.unit_price is not None else data.price
+    if price_val is not None:
+        set_fields["price"] = float(price_val)
+    if data.article is not None:
+        set_fields["supplier_item_code"] = str(data.article).strip()
+    if data.name is not None:
+        set_fields["name_raw"] = str(data.name).strip()
+        set_fields["name_norm"] = (str(data.name).lower().strip().replace("  ", " ") or "")
+    if data.unit is not None:
+        set_fields["unit_supplier"] = str(data.unit).strip() or "шт"
+        set_fields["unit_norm"] = set_fields["unit_supplier"] if set_fields["unit_supplier"] in ("pcs", "kg", "l") else "pcs"
+    if data.pack_quantity is not None:
+        set_fields["pack_qty"] = max(1, int(data.pack_quantity))
+    if data.min_order is not None:
+        set_fields["min_order_qty"] = max(1, int(data.min_order))
     if data.availability is not None:
         set_fields["active"] = data.availability
     if data.active is not None:
         set_fields["active"] = data.active
-    set_fields["updated_at"] = datetime.now(timezone.utc)
-    if not set_fields:
-        set_fields["updated_at"] = datetime.now(timezone.utc)
     match = {"id": price_id, "$or": [{"supplier_company_id": company_id}, {"supplierCompanyId": company_id}]}
     result = await db.supplier_items.update_one(match, {"$set": set_fields})
     if result.matched_count == 0:
@@ -951,13 +1201,17 @@ async def update_price_list(price_id: str, data: PriceListUpdate, current_user:
     updated = si.get("updated_at")
     return {
         "id": si.get("id", price_id),
+        "article": si.get("supplier_item_code", ""),
+        "name": si.get("name_raw", ""),
+        "unit": si.get("unit_supplier", si.get("unit_norm", "шт")),
+        "pack_quantity": int(si.get("pack_qty", 1)),
+        "min_order": int(si.get("min_order_qty", 1)),
+        "unit_price": float(si.get("price", 0)),
+        "availability": bool(si.get("active", True)),
         "supplierCompanyId": si.get("supplier_company_id", company_id),
         "productName": si.get("name_raw", ""),
-        "article": si.get("supplier_item_code", ""),
         "price": float(si.get("price", 0)),
-        "unit": si.get("unit_supplier", si.get("unit_norm", "шт")),
         "minQuantity": int(si.get("min_order_qty", 1)),
-        "availability": True,
         "active": si.get("active", True),
         "createdAt": created.isoformat() if hasattr(created, "isoformat") else str(created),
         "updatedAt": updated.isoformat() if hasattr(updated, "isoformat") else str(updated),
@@ -983,6 +1237,7 @@ async def delete_price_list(price_id: str, current_user: dict = Depends(get_curr
         raise HTTPException(status_code=404, detail="Price list not found")
     return {"message": "Price list deleted"}
 
+@api_router.post("/supplier/price-list")
 @api_router.post("/price-lists/upload")
 async def upload_price_list(file: UploadFile = File(...), current_user: dict = Depends(get_current_user)):
     if current_user['role'] != UserRole.supplier:
diff --git a/frontend/src/context/AuthContext.js b/frontend/src/context/AuthContext.js
index 5776957..8f1466a 100644
--- a/frontend/src/context/AuthContext.js
+++ b/frontend/src/context/AuthContext.js
@@ -3,7 +3,7 @@ import axios from 'axios';
 
 const AuthContext = createContext(null);
 
-const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;
+const BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8000';
 const API = `${BACKEND_URL}/api`;
 
 export const AuthProvider = ({ children }) => {
@@ -42,6 +42,16 @@ export const AuthProvider = ({ children }) => {
     return userData;
   };
 
+  const devLogin = async (role) => {
+    const response = await axios.post(`${API}/dev/login`, { role });
+    const { access_token, user: userData } = response.data;
+    localStorage.setItem('token', access_token);
+    setToken(access_token);
+    setUser(userData);
+    axios.defaults.headers.common['Authorization'] = `Bearer ${access_token}`;
+    return userData;
+  };
+
   const register = async (data, type) => {
     const endpoint = type === 'supplier' ? '/auth/register/supplier' : '/auth/register/customer';
     const response = await axios.post(`${API}${endpoint}`, data);
@@ -61,7 +71,7 @@ export const AuthProvider = ({ children }) => {
   };
 
   return (
-    <AuthContext.Provider value={{ user, loading, login, register, logout }}>
+    <AuthContext.Provider value={{ user, loading, login, register, logout, devLogin }}>
       {children}
     </AuthContext.Provider>
   );
diff --git a/frontend/src/pages/AuthPage.js b/frontend/src/pages/AuthPage.js
index e84ea49..5802fb2 100644
--- a/frontend/src/pages/AuthPage.js
+++ b/frontend/src/pages/AuthPage.js
@@ -3,9 +3,28 @@ import { useNavigate } from 'react-router-dom';
 import { Card } from '@/components/ui/card';
 import { Button } from '@/components/ui/button';
 import { Building2, Store } from 'lucide-react';
+import { useAuth } from '@/context/AuthContext';
+
+const DEV_AUTH_BYPASS = process.env.REACT_APP_DEV_AUTH_BYPASS === '1';
 
 export const AuthPage = () => {
   const navigate = useNavigate();
+  const { devLogin } = useAuth();
+  const [devLoading, setDevLoading] = useState(null);
+
+  const handleDevLogin = async (role) => {
+    if (!DEV_AUTH_BYPASS) return;
+    try {
+      setDevLoading(role);
+      await devLogin(role);
+      navigate(role === 'supplier' ? '/supplier/price-list' : '/customer');
+    } catch (e) {
+      console.error('DEV login failed:', e);
+      setDevLoading(null);
+    } finally {
+      setDevLoading(null);
+    }
+  };
 
   return (
     <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
@@ -53,7 +72,31 @@ export const AuthPage = () => {
           </Card>
         </div>
         
-        <div className="mt-6 text-center">
+        <div className="mt-6 text-center space-y-2">
+          {DEV_AUTH_BYPASS && (
+            <div className="flex justify-center gap-2 pb-2">
+              <Button
+                variant="outline"
+                size="sm"
+                className="text-xs text-amber-700 border-amber-300"
+                onClick={() => handleDevLogin('supplier')}
+                disabled={!!devLoading}
+                data-testid="dev-login-supplier-btn"
+              >
+                {devLoading === 'supplier' ? '...' : 'DEV: Войти как поставщик'}
+              </Button>
+              <Button
+                variant="outline"
+                size="sm"
+                className="text-xs text-amber-700 border-amber-300"
+                onClick={() => handleDevLogin('customer')}
+                disabled={!!devLoading}
+                data-testid="dev-login-customer-btn"
+              >
+                {devLoading === 'customer' ? '...' : 'DEV: Войти как ресторан'}
+              </Button>
+            </div>
+          )}
           <Button variant="ghost" onClick={() => navigate('/')} data-testid="back-to-home-btn">
             Вернуться на главную
           </Button>
